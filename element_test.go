package galois

import (
	"testing"
)

func TestFieldElement(t *testing.T) {
	t.Run("elements are cyclic over exponentiation", func(t *testing.T) {
		type TestCase struct {
			Modulus            Polynomial
			Exponent           uint64
			ExpectedPolynomial Polynomial
		}

		testCases := []TestCase{
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           0,
				ExpectedPolynomial: 0b001,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           1,
				ExpectedPolynomial: 0b010,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           2,
				ExpectedPolynomial: 0b100,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           3,
				ExpectedPolynomial: 0b011,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           4,
				ExpectedPolynomial: 0b110,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           5,
				ExpectedPolynomial: 0b111,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           6,
				ExpectedPolynomial: 0b101,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           7,
				ExpectedPolynomial: 0b001,
			},
			{
				Modulus:            PrimePolynomialDegree3,
				Exponent:           8,
				ExpectedPolynomial: 0b010,
			},
		}

		for _, test := range testCases {
			element := GenerateFieldElement(test.Exponent, test.Modulus)

			if actual := element.Polynomial; actual != test.ExpectedPolynomial {
				t.Errorf(
					"expected x^%d mod %s = %s - got %q",
					test.Exponent, test.Modulus, test.ExpectedPolynomial, actual,
				)
			}
		}
	})

	t.Run("elements are unique and have inverses", func(t *testing.T) {
		primes := []Polynomial{
			PrimePolynomialDegree2,
			PrimePolynomialDegree3,
			PrimePolynomialDegree4,
			PrimePolynomialDegree5,
			PrimePolynomialDegree6,
			PrimePolynomialDegree7,
			PrimePolynomialDegree8,
			PrimePolynomialDegree9,
			PrimePolynomialDegree10,
			PrimePolynomialDegree11,
			PrimePolynomialDegree12,
			PrimePolynomialDegree13,
			PrimePolynomialDegree14,
			PrimePolynomialDegree15,
			PrimePolynomialDegree16,
		}

		for _, prime := range primes {
			seen := make(map[Polynomial]uint64)

			for index := uint64(0); index < FieldOrder(prime); index++ {
				element := GenerateFieldElement(index, prime)
				poly := element.Polynomial
				if otherIndex, ok := seen[poly]; ok {
					t.Errorf(
						"unexpected duplicate polynomial %q in finite field %q, generated by x^%d and x^%d",
						poly, prime, index, otherIndex,
					)
				}
				seen[poly] = index

				if inverted := element.MultInverse().Mul(element); !inverted.IsMultIdentity() {
					t.Errorf(
						"expected element to have an inverse which yields 1 when multiplied;\n"+
							"found (%s) * (%s) = %s", element, element.MultInverse(), inverted,
					)
					continue
				}
			}
		}
	})

	t.Run("multiplyig elements corresponds to adding exponents of Generator", func(t *testing.T) {
		type TestCase struct {
			ExponentA uint64
			ExponentB uint64
			Modulus   Polynomial
		}

		testCases := []TestCase{
			{
				ExponentA: 0,
				ExponentB: 0,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 0,
				ExponentB: 1,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 1,
				ExponentB: 1,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 1,
				ExponentB: 2,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 2,
				ExponentB: 2,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 3,
				ExponentB: 7,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 11,
				ExponentB: 254,
				Modulus:   PrimePolynomialDegree8,
			},
			{
				ExponentA: 374,
				ExponentB: 481,
				Modulus:   PrimePolynomialDegree8,
			},
		}

		for _, test := range testCases {
			elementA := GenerateFieldElement(test.ExponentA, test.Modulus)
			elementB := GenerateFieldElement(test.ExponentB, test.Modulus)

			expectedExponent := (test.ExponentA + test.ExponentB) % FieldOrder(test.Modulus)
			expectedElement := GenerateFieldElement(expectedExponent, test.Modulus)

			if product := elementA.Mul(elementB); !product.Equal(expectedElement) {
				t.Errorf(
					"field element multiplication failed; expected (%s) * (%s) = %s (got %s)",
					elementA, elementB, expectedElement, product,
				)
			}
		}
	})

	t.Run("elements can be exponentiated", func(t *testing.T) {
		type TestCase struct {
			Base     Polynomial
			Exponent uint64
			Modulus  Polynomial
			Expected Polynomial
		}

		testCases := []TestCase{
			{
				Base:     0b100101,
				Exponent: 0,
				Modulus:  PrimePolynomialDegree6,
				Expected: 1,
			},
			{
				Base:     0b100101,
				Exponent: 1,
				Modulus:  PrimePolynomialDegree6,
				Expected: 0b100101,
			},
			{
				Base:     0b100101,
				Exponent: 4,
				Modulus:  PrimePolynomialDegree3,
				Expected: 0b110,
			},
			{
				Base:     0b11,
				Exponent: 7,
				Modulus:  PrimePolynomialDegree4,
				Expected: 0b1101,
			},
			{
				Base:     0b1011,
				Exponent: FieldOrder(PrimePolynomialDegree4),
				Modulus:  PrimePolynomialDegree4,
				Expected: 0b1,
			},
			{
				Base:     0b1011,
				Exponent: FieldOrder(PrimePolynomialDegree4) + 1,
				Modulus:  PrimePolynomialDegree4,
				Expected: 0b1011,
			},
			{
				Base:     0b10011,
				Exponent: FieldOrder(PrimePolynomialDegree5) + 1,
				Modulus:  PrimePolynomialDegree5,
				Expected: 0b10011,
			},
			{
				Base:     0b10001,
				Exponent: 2,
				Modulus:  PrimePolynomialDegree5,
				Expected: 0b1100,
			},
		}

		for _, test := range testCases {
			elem := NewFieldElement(test.Base, test.Modulus)

			if actual := elem.Exp(test.Exponent); actual.Polynomial != test.Expected {
				t.Errorf(
					"field element exponentiation failed; expected (%s)^%d mod %s = %s (got %s)",
					test.Base, test.Exponent, test.Modulus, test.Expected, actual,
				)
			}
		}
	})
}

func BenchmarkGenerateFieldElement_8(b *testing.B) {
	for i := 0; i < b.N; i++ {
		GenerateFieldElement(0b1111111, PrimePolynomialDegree8)
	}
}
func BenchmarkGenerateFieldElement_12(b *testing.B) {
	for i := 0; i < b.N; i++ {
		GenerateFieldElement(0b11111111111, PrimePolynomialDegree12)
	}
}
func BenchmarkGenerateFieldElement_16(b *testing.B) {
	for i := 0; i < b.N; i++ {
		GenerateFieldElement(0b111111111111111, PrimePolynomialDegree16)
	}
}
func BenchmarkGenerateFieldElement_20(b *testing.B) {
	for i := 0; i < b.N; i++ {
		GenerateFieldElement(32767, PrimePolynomialDegree20)
	}
}
func BenchmarkGenerateFieldElement_32(b *testing.B) {
	for i := 0; i < b.N; i++ {
		GenerateFieldElement(0b1111111111111111111111111111111, PrimePolynomialDegree32)
	}
}

func BenchmarkFieldElement_Exp_32(b *testing.B) {
	elem := NewFieldElement(0b10101010101010101010101010101010, PrimePolynomialDegree32)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		elem.Exp(FieldOrder(PrimePolynomialDegree32) - 1)
	}
}

func BenchmarkFieldElement_MultInverse_8(b *testing.B) {
	elem := NewFieldElement(0b10101010, PrimePolynomialDegree8)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		elem.MultInverse()
	}
}
func BenchmarkFieldElement_MultInverse_16(b *testing.B) {
	elem := NewFieldElement(0b1010101010101010, PrimePolynomialDegree16)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		elem.MultInverse()
	}
}
func BenchmarkFieldElement_MultInverse_24(b *testing.B) {
	elem := NewFieldElement(0b101010101010101010101010, PrimePolynomialDegree24)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		elem.MultInverse()
	}
}
func BenchmarkFieldElement_MultInverse_32(b *testing.B) {
	elem := NewFieldElement(0b10101010101010101010101010101010, PrimePolynomialDegree32)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		elem.MultInverse()
	}
}
